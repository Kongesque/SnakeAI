{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/app/snake.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { useRef, useEffect} from 'react';\nimport p5 from 'p5';\nimport dynamic from 'next/dynamic';\n\nconst SnakeGame: React.FC = () => {\n    const canvasRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n\n      let blocksX = 40, blocksY = 20;\n      let maxBlocks = 1000, blockSize: number, xOffset = 0, yOffset = 0, s: any, pause = false, speedMultiplier = 1, hc: any, outlineLength = 3, setup_i = 0;\n    \n      const sketch = (p: p5) => {\n          p.setup = () => {\n              setup_i++;\n              let a = canvasRef.current;\n              if (!a) return; // Ensure canvasRef.current is defined\n              blockSize = Math.min(a.offsetWidth / blocksX, a.offsetHeight / blocksY);\n              p.createCanvas(a.offsetWidth - blockSize, a.offsetHeight - blockSize).parent(a);\n              p.pixelDensity(15);\n              setBlocks();\n              blockSize = Math.min(p.width / blocksX, p.height / blocksY);\n              outlineLength = blockSize / 15;\n              yOffset = xOffset = 0;\n              if (setup_i == 1) p.setup();\n              s = new Snake(p);\n              hc = new HamiltonianCycle(blocksX, blocksY, p);\n              s.resetOnHamiltonian(hc.cycle);\n              p.frameRate(30);\n            \n              let isSpeedUp = false;\n              const toggleSpeed = () => {\n                  isSpeedUp = !isSpeedUp;\n                  speedMultiplier = isSpeedUp ? 10 : 1;\n              }\n              \n              if (a) {\n                a.addEventListener('mouseover', toggleSpeed);\n                a.addEventListener('mouseout', toggleSpeed);\n                a.addEventListener('touchstart', toggleSpeed);\n              }\n              \n              window.addEventListener(\"resize\", resize);\n          };\n    \n          const setBlocks = () => {\n              let a = 1;\n              for (; ;) {\n                  if (Math.floor(p.width / a) * Math.floor(p.height / a) < maxBlocks) {\n                      blockSize = a;\n                      blocksX = Math.floor(p.width / blockSize) - Math.floor(p.width / blockSize) % 2 - 2;\n                      blocksY = Math.floor(p.height / blockSize) - Math.floor(p.height / blockSize) % 2;\n                      break;\n                  } else a++;\n              }\n          };\n          const resize = () => {\n              blockSize = Math.min(p.width / blocksX, p.height / blocksY);\n              outlineLength = blockSize / 15;\n              xOffset = (p.width - blockSize * blocksX) / 2;\n              yOffset = (p.height - blockSize * blocksY) / 2;\n              p.setup();\n          }\n          let resizeDelay: any;\n          const windowResized = () => {\n              clearTimeout(resizeDelay);\n              resizeDelay = setTimeout(resize, 500)\n          }\n           p.windowResized = windowResized\n          p.draw = () => {\n              if (!pause) {\n                p.background(\"#202222\");\n                p.stroke(\"#202222\");\n                p.strokeWeight(1);\n                p.fill(20);\n                p.rect(0, 0, p.width, yOffset);\n                p.rect(0, 0, xOffset, p.height);\n                p.rect(p.width, p.height, -p.width, -yOffset);\n                p.rect(p.width, p.height, -xOffset, -p.height);\n                p.push();\n                p.translate(xOffset, yOffset);\n                p.fill(0);\n                s.show();\n                for (let a = 0; a < speedMultiplier; a++) s.update();\n                p.pop();\n              }\n          };\n\n         class Snake {\n              x: number;\n              y: number;\n              tailBlocks: p5.Vector[];\n              velX: number;\n              velY: number;\n              apple: Apple;\n              addCount: number;\n              survivalMode: boolean;\n              dead: boolean;\n              path: any;\n              weWin: boolean;\n              lateGame: boolean;\n              noMoreAStar: boolean;\n              searchForLongestPathModeActive: boolean;\n              controlledByPlayer: boolean;\n              cycle: any;\n              headCyclePosition: number;\n              tailCyclePosition: number;\n              appleCyclePosition: any;\n              constructor(p: p5) {\n                this.x = Math.floor(blocksX / 2);\n                this.y = Math.floor(blocksY / 2);\n                this.tailBlocks = [];\n                this.tailBlocks.push(p.createVector(this.x - 3, this.y));\n                this.tailBlocks.push(p.createVector(this.x - 2, this.y));\n                this.tailBlocks.push(p.createVector(this.x - 1, this.y));\n                this.velX = 1;\n                this.velY = 0;\n                this.apple = new Apple(this,p);\n                this.addCount = 0;\n                this.survivalMode = this.dead = false;\n                this.path = null;\n                this.weWin = this.lateGame = this.noMoreAStar = this.searchForLongestPathModeActive = this.controlledByPlayer = false;\n                this.cycle = null;\n                this.headCyclePosition = 0;\n                this.tailCyclePosition = 0;\n              }\n              resetOnHamiltonian(a: any) {\n                this.cycle = a;\n                this.tailBlocks = [];\n                this.tailBlocks.push(p.createVector(a[0].x, a[0].y));\n                this.tailBlocks.push(p.createVector(a[1].x, a[1].y));\n                this.tailBlocks.push(p.createVector(a[2].x, a[2].y));\n                this.x = a[3].x;\n                this.y = a[3].y;\n                this.apple = new Apple(this,p);\n                this.headCyclePosition = 3;\n                this.tailCyclePosition = 0;\n              }\n                show() {\n                    p.noStroke();\n                    p.fill(\"#e8e8e6\");\n                    p.ellipse(this.x * blockSize + blockSize / 2, this.y * blockSize + blockSize / 2, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    p.rect((this.x + this.tailBlocks[this.tailBlocks.length - 1].x) * blockSize / 2 + outlineLength, (this.y + this.tailBlocks[this.tailBlocks.length - 1].y) * blockSize / 2 + outlineLength, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    for (var a = 0; a < this.tailBlocks.length; a++)\n                        p.ellipse(this.tailBlocks[a].x * blockSize + blockSize / 2, this.tailBlocks[a].y * blockSize + blockSize / 2, blockSize - outlineLength * 2, blockSize - outlineLength * 2),\n                            a < this.tailBlocks.length - 1 && p.rect((this.tailBlocks[a].x + this.tailBlocks[a + 1].x) / 2 * blockSize + outlineLength, (this.tailBlocks[a].y + this.tailBlocks[a + 1].y) / 2 * blockSize + outlineLength, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    this.weWin || this.apple.show();\n                }\n                move() {\n                    if (!this.weWin) {\n                        if (!this.controlledByPlayer)\n                            if ((!this.path || this.path.pathCounter >= this.path.pathLength) && this.calculatePath(), this.path && this.path.pathLength !== 0) {\n                                var a = this.path.getNextMove();\n                                this.velX = a.x;\n                                this.velY = a.y;\n                            } else {\n                                var a = this.getNextPosition();\n                                this.velX = a.x - this.x;\n                                this.velY = a.y - this.y;\n                            }\n                        this.addCount <= 0 ? (this.tailBlocks.splice(0, 1), this.tailCyclePosition = (this.tailCyclePosition + 1) % this.cycle.length) : this.addCount--;\n                        this.tailBlocks.push(p.createVector(this.x, this.y));\n                        this.x += this.velX;\n                        this.y += this.velY;\n                    }\n                }\n                getNextPosition() {\n                    this.appleCyclePosition = hc.getNodeNo(this.apple.x, this.apple.y);\n                    let a = hc.getPossiblePositionsFrom(this.x, this.y),\n                        b = 100000,\n                        c = 0;\n                    for (let d = 0; d < a.length; d++) {\n                        let e = this.appleCyclePosition - a[d];\n                        for (; e < 0;) e += this.cycle.length;\n                        !this.overTakesTail(this.cycle[a[d]]) && e < b && (b = e, c = d);\n                    }\n                    return b === 100000 ? this.cycle[(hc.getNodeNo(this.x, this.y) + 1) % this.cycle.length] : this.cycle[a[c]];\n                }\n              overTakesTail(a: any, b?: any, c?: any) {\n                  b = b ? b.cycleNo : hc.getNodeNo(this.x, this.y);\n                  c = c ? hc.getNodeNo(c.x, c.y) : hc.getNodeNo(this.tailBlocks[0].x, this.tailBlocks[0].y);\n                  if (this.getDistanceBetweenPoints(b, c) <= 50 + this.addCount) return true;\n                  c = c - 50 - this.addCount;\n                  c < 0 && (c += this.cycle.length);\n                  return this.getDistanceBetweenPoints(b, a.cycleNo) >= this.getDistanceBetweenPoints(b, c) ? true : false;\n              }\n                getPathBasedOnAStar() {\n                  for (var a of this.cycle) a.resetForAStar();\n                    this.appleCyclePosition = hc.getNodeNo(this.apple.x, this.apple.y);\n                  var b = this.cycle[hc.getNodeNo(this.x, this.y)];\n                    a = [];\n                    let c: any;\n                    b = new HPath(b, this.cycle[this.appleCyclePosition],p);\n                    for (a.push(b);;) {\n                        if (a.length === 0) return c;\n                      b = a.shift();\n                        if (c && b.pathLength >= c.pathLength) continue;\n                        if (b.distanceToApple === 0) {\n                            if (c == null || b.pathLength < c.pathLength) c = b.clone();\n                            continue;\n                        }\n                        let e = b.getLastNode();\n                        if (!e.alreadyVisited || b.pathLength < e.shortestDistanceToThisPoint) {\n                            e.alreadyVisited = true;\n                            e.shortestDistanceToThisPoint = b.pathLength;\n                            for (var d of e.edges) {\n                              if (this.overTakesTail(d, e, b.getSnakeTailPositionAfterFollowingPath(this)) && d.cycleNo !== e.cycleNo + 1) continue;\n                                let f = b.clone();\n                                f.addToTail(d);\n                                f.getLastNode().alreadyVisited && f.pathLength > f.getLastNode().shortestDistanceToThisPoint || a.push(f);\n                            }\n                        }\n                        a.sort((f: HPath, n: HPath) => f.distanceToApple + f.pathLength - (n.distanceToApple + n.pathLength));\n                    }\n                }\n                getDistanceBetweenPoints(a: any, b: any) {\n                  for (a = b - a; a < 0;) a += this.cycle.length;\n                  return a;\n              }\n              checkFuturePos() {\n                  this.x += this.velX;\n                  this.y += this.velY;\n                  for (var a = 0; a < this.tailBlocks.length; a++) this.tailBlocks[a].x === this.x && this.tailBlocks[a].y === this.y && (this.dead = true);\n                  if (this.x < 0 || this.x >= blocksX || this.y < 0 || this.y >= blocksY) this.dead = true;\n                  this.x -= this.velX;\n                  this.y -= this.velY;\n                  this.dead && (this.dead = false, pause = true);\n              }\n                update() {\n                    this.dead || (this.move(), this.checkCollisions());\n                }\n                checkCollisions() {\n                    if (blocksX * blocksY - (this.tailBlocks.length + 1) <= 0) this.weWin = true, p.setup();\n                    else {\n                        for (var a = 0; a < this.tailBlocks.length; a++) if (this.tailBlocks[a].x === this.x && this.tailBlocks[a].y === this.y) {\n                            this.dead = true;\n                            return;\n                        }\n                        this.x < 0 || this.x >= blocksX || this.y < 0 || this.y >= blocksY ? this.dead = true : this.x === this.apple.x && this.y === this.apple.y && this.ateApple();\n                    }\n                }\n                ateApple() {\n                    this.addCount += 4;\n                    this.apple = new Apple(this,p);\n                    this.calculatePath();\n                }\n                calculatePath() {\n                    this.path = this.getPathBasedOnAStar();\n                }\n                isAppleOnSnake(a: any) {\n                    return this.snakeAtPosition(a.x, a.y);\n                }\n                snakeAtPosition(a: any, b: any) {\n                    return this.snakeTailAtPosition(a, b) || this.x == a && this.y == b;\n                }\n                snakeTailAtPosition(a: any, b: any) {\n                  for (var c = 0; c < this.tailBlocks.length; c++) if (this.tailBlocks[c].x == a && this.tailBlocks[c].y == b) return true;\n                    return false;\n                }\n            }\n          class Apple {\n              x: number;\n              y: number;\n              constructor(a: Snake,p: p5) {\n                  this.x = Math.floor(p.random(blocksX));\n                  for (this.y = Math.floor(p.random(blocksY)); a.isAppleOnSnake(this);) this.x = Math.floor(p.random(blocksX)), this.y = Math.floor(p.random(blocksY));\n                \n              }\n            show() {\n                p.noStroke();\n                p.fill(\"#21b8cd\");\n                p.push();\n                p.translate(this.x * blockSize + outlineLength, this.y * blockSize + outlineLength);\n                p.ellipse(blockSize / 2, blockSize / 2, blockSize - 2 * outlineLength, blockSize - 2 * outlineLength);\n                p.pop();\n            }\n                isAtPosition(a: any, b: any) {\n                  return this.x === a && this.y === b;\n              }\n          }\n\n          class HamiltonianCycle {\n              w: number;\n              h: number;\n              cycle: any[];\n              spanningTreeNodes: HNode[];\n              constructor(a: number, b: number,p: p5) {\n                  this.w = a;\n                  this.h = b;\n                this.cycle = [];\n                  this.spanningTreeNodes = [];\n                this.createCycle(p);\n              }\n              createCycle(p: p5) {\n                this.createSpanningTree(p);\n                  var a:any[] = [];\n                  let b:HNode[] = [];\n                  for (let i = 0; i < this.w; i++)\n                      for (var c = 0; c < this.h; c++) b.push(new HNode(i, c));\n                  for (var d of b) d.setEdges(b);\n                  for (let i = 0; i < this.spanningTreeNodes.length; i++) {\n                      let d = this.spanningTreeNodes[i];\n                      for (let e of d.spanningTreeAdjacentNodes) {\n                          let c = (p: any, t: any, q: any, u: any) => {\n                              t + this.h * p >= b.length || u + this.h * q >= b.length || (p = b[t + this.h * p], q = b[u + this.h * q], p.spanningTreeAdjacentNodes.push(q), q.spanningTreeAdjacentNodes.push(p))\n                          };\n                          let k = d.getDirectionTo(e),\n                              l = d.x * 2,\n                              m = d.y * 2;\n                          k.x === 1 ? (c(l + 1, m, l + 2, m), c(l + 1, m + 1, l + 2, m + 1)) :\n                              k.y === 1 && (c(l, m + 1, l, m + 2), c(l + 1, m + 1, l + 1, m + 2));\n                      }\n                  }\n                  a = b.filter(k => k.spanningTreeAdjacentNodes.length === 1);\n                    let e: HEdge[] = [];\n                    for (let f of a) {\n                        let dir = f.spanningTreeAdjacentNodes[0].getDirectionTo(f);\n                        dir.x += f.x;\n                        dir.y += f.y;\n                        let edge = new HEdge(b[dir.y + this.h * dir.x], f);\n                        let d = true;\n                        for (let n of e) if (n.isEqualTo(edge)) {\n                            d = false;\n                            break;\n                        }\n                        d && e.push(edge);\n                    }\n                  for (let k of e) k.connectNodes();\n                  a = b.filter(k => k.spanningTreeAdjacentNodes.length === 1);\n                    e = [];\n                    for (let g of a)\n                        for (let h of a)\n                            if (p.dist(g.x, g.y, h.x, h.y) === 1 && Math.floor(g.x / 2) === Math.floor(h.x / 2) && Math.floor(g.y / 2) === Math.floor(h.y / 2)) {\n                                let f = new HEdge(h, g);\n                                let n = true;\n                                for (let r of e) if (r.isEqualTo(f)) {\n                                    n = false;\n                                    break;\n                                }\n                                n && e.push(f);\n                                break;\n                            }\n                  for (let k of e) k.connectNodes();\n                let randomElement = b[Math.floor(p.random(b.length))];\n                a = [randomElement];\n                  let g = a[0];\n                  for (let h = a[0].spanningTreeAdjacentNodes[0]; h !== a[0];) {\n                      let r = h.spanningTreeAdjacentNodes[0];\n                      r === g && (r = h.spanningTreeAdjacentNodes[1]);\n                      a.push(h);\n                      g = h;\n                      h = r;\n                  }\n                  this.cycle = a;\n                for (g = 0; g < this.cycle.length; g++) this.cycle[g].cycleNo = g;\n              }\n              show(p: p5) {\n                  for (let a = 0; a < this.cycle.length; a++)\n                      p.push(),\n                          p.translate(blockSize / 2, blockSize / 2),\n                          p.scale(blockSize),\n                          p.fill(255),\n                          p.textAlign(p.CENTER, p.CENTER),\n                          p.textSize(.3),\n                          p.text(a, this.cycle[a].x, this.cycle[a].y),\n                          p.stroke(255, 100),\n                          p.strokeWeight(.1),\n                          a !== this.cycle.length - 1 ? p.line(this.cycle[a].x, this.cycle[a].y, this.cycle[a + 1].x, this.cycle[a + 1].y) :\n                              p.line(this.cycle[a].x, this.cycle[a].y, this.cycle[0].x, this.cycle[0].y),\n                          p.pop();\n              }\n              createSpanningTree(p: p5) {\n                  let a: HNode[] = [];\n                  for (var b = 0; b < this.w / 2; b++) for (let i = 0; i < this.h / 2; i++) a.push(new HNode(b, i));\n                  for (var d of a) d.setEdges(a);\n                  let edges: HEdge[] = [];\n                  let c = a[Math.floor(p.random(a.length))];\n                  edges.push(new HEdge(c, c.edges[0]));\n                  let e = [c, c.edges[0]];\n                  for (; e.length < a.length;) {\n                      c = (e as any).getRandomElement(p);\n                      const filteredEdges = c.edges.filter((f: HNode) => !e.includes(f));\n                      if (filteredEdges.length !== 0) {\n                          d = (filteredEdges as any).getRandomElement(p);\n                          e.push(d);\n                          edges.push(new HEdge(c, d));\n                      }\n                  }\n                  for (let f of a) f.setSpanningTreeEdges(edges);\n                  this.spanningTreeNodes = a;\n              }\n              getNextPosition(a: any, b: any) {\n                  for (let c = 0; c < this.cycle.length; c++) if (this.cycle[c].x === a && this.cycle[c].y === b) return this.cycle[(c + 1) % this.cycle.length];\n                  return null;\n              }\n              getNodeNo(a: any, b: any) {\n                  for (let c = 0; c < this.cycle.length; c++) if (this.cycle[c].x === a && this.cycle[c].y === b) return c;\n                  return -1;\n              }\n              getPossiblePositionsFrom(a: any, b: any) {\n                  a = this.cycle[this.getNodeNo(a, b)];\n                  let positions: number[] = [];\n                  for (let c of a.edges) positions.push(this.getNodeNo(c.x, c.y));\n                  return positions;\n              }\n          }\n           \n          (Array.prototype as any).getRandomElement = function (p: p5): any {\n            return this[Math.floor(p.random(this.length))];\n          };\n\n          class HNode {\n              x: number;\n              y: number;\n              spanningTreeAdjacentNodes: HNode[];\n              cycleNo: number;\n              alreadyVisited: boolean;\n              shortestDistanceToThisPoint: number;\n              edges: HNode[];\n            constructor(a: number, b: number) {\n                  this.x = a;\n                  this.y = b;\n                  this.spanningTreeAdjacentNodes = [];\n                  this.cycleNo = -1;\n                  this.alreadyVisited = false;\n                  this.shortestDistanceToThisPoint = 0;\n                this.edges = [];\n              }\n              setEdges(a: HNode[]) {\n                this.edges = a.filter(b => p.dist(b.x, b.y, this.x, this.y) === 1)\n              }\n              setSpanningTreeEdges(a: HEdge[]) {\n                  for (let b of a) b.contains(this) && this.spanningTreeAdjacentNodes.push(b.getOtherNode(this));\n              }\n              getNextNodeMovingLeft(a: HNode): HNode {\n                let b = a.getDirectionTo(this);\n                let directions: { x: number; y: number; }[] = [];\n                for (var c of this.spanningTreeAdjacentNodes) directions.push(this.getDirectionTo(c));\n                for (let c = getLeftOf(b); !directions.some(dir => dir.x === c.x && dir.y === c.y);) c = getRightOf(c);\n                return this.spanningTreeAdjacentNodes[directions.findIndex(dir => dir.x === c.x && dir.y === c.y)];\n              }\n              getDirectionTo(a: HNode): { x: number; y: number; } {\n                return { x: a.x - this.x, y: a.y - this.y };\n              }\n              resetForAStar() {\n                  this.alreadyVisited = false;\n                  this.shortestDistanceToThisPoint = 0;\n              }\n          }\n           function getLeftOf(a: { x: number; y: number; }): { x: number; y: number; } {\n              return a.x === 0 && a.y === 1 ? { x: 1, y: 0 } :\n                  a.x === 0 && a.y === -1 ? { x: -1, y: 0 } :\n                      a.x === 1 ? { x: 0, y: -1 } : { x: 0, y: 1 }\n          }\n          function getRightOf(a: { x: number; y: number; }): { x: number; y: number; } {\n              return a.x === 0 && a.y === 1 ? { x: -1, y: 0 } :\n                  a.x === 0 && a.y === -1 ? { x: 1, y: 0 } :\n                      a.x === 1 ? { x: 0, y: 1 } : { x: 0, y: -1 }\n          }\n          class HEdge {\n              node1: HNode;\n              node2: HNode;\n              constructor(a: HNode, b: HNode) {\n                  this.node1 = a;\n                  this.node2 = b;\n              }\n              isEqualTo(a: HEdge): boolean {\n                  return this.node1 === a.node1 && this.node2 === a.node2 || this.node1 === a.node2 && this.node2 === a.node1;\n              }\n              contains(a: HNode): boolean {\n                  return a === this.node1 || a === this.node2;\n              }\n              getOtherNode(a: HNode): HNode {\n                  return a === this.node1 ? this.node2 : this.node1;\n              }\n              connectNodes() {\n                  this.node1.spanningTreeAdjacentNodes.push(this.node2);\n                  this.node2.spanningTreeAdjacentNodes.push(this.node1);\n              }\n          }\n          class HPath {\n              pathLength: number;\n              nodesInPath: HNode[];\n              finishNode: HNode;\n              distanceToApple: number;\n              pathCounter: number;\n              constructor(a: HNode, b: HNode, p:p5) {\n                  this.pathLength = 0;\n                  this.nodesInPath = [a];\n                  this.finishNode = b;\n                  this.distanceToApple = 0;\n                  this.setDistanceToApple(p);\n                  this.pathCounter = 0;\n                \n              }\n              setDistanceToApple(p: p5) {\n                  this.distanceToApple = p.dist(this.finishNode.x, this.finishNode.y, this.getLastNode().x, this.getLastNode().y);\n              }\n              addToTail(a: HNode) {\n                  this.nodesInPath.push(a);\n                  this.pathLength += 1;\n                  this.setDistanceToApple(p);\n              }\n              getLastNode(): HNode {\n                  return this.nodesInPath[this.nodesInPath.length - 1];\n              }\n              getSnakeTailPositionAfterFollowingPath(a: Snake): HNode {\n                  const tailBlocksAsHNodes = a.tailBlocks.map(block => new HNode(block.x, block.y));\n                  return this.pathLength - a.addCount < tailBlocksAsHNodes.length ?\n                      tailBlocksAsHNodes[Math.max(0, this.pathLength - a.addCount)]\n                      :\n                      this.nodesInPath[this.pathLength - a.addCount - tailBlocksAsHNodes.length];\n              }\n              getNextMove(): { x: number; y: number; } {\n                  let a = this.nodesInPath[this.pathCounter + 1].x - this.nodesInPath[this.pathCounter].x,\n                      b = this.nodesInPath[this.pathCounter + 1].y - this.nodesInPath[this.pathCounter].y;\n                  this.pathCounter++;\n                  return { x: a, y: b };\n              }\n              clone(): HPath {\n                  let a = new HPath(this.nodesInPath[0], this.finishNode,p);\n                  a.nodesInPath = [...this.nodesInPath];\n                  a.pathLength = this.pathLength;\n                  a.distanceToApple = this.distanceToApple;\n                  return a;\n              }\n          }\n      };\n        if (canvasRef.current) {\n            new p5(sketch, canvasRef.current);\n        }\n    }, []);\n    \n    return (\n        <div className=\"w-full aspect-[2.35/1] bg-[#202222] rounded-md border-[2px] border-[#3d3f40]\" id=\"snake-game-container\">\n            <div className=\"flex justify-center items-center h-full\" id=\"snake-game\" ref={canvasRef}></div>\n        </div>\n        \n    );\n};\n\nexport default dynamic(() => Promise.resolve(SnakeGame), { ssr: false });"],"names":[],"mappings":"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"}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}