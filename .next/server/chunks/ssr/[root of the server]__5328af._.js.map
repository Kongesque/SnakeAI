{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/app/snake.tsx"],"sourcesContent":["\"use client\";\nimport React, { useRef, useEffect} from 'react';\nimport dynamic from 'next/dynamic';\n\nconst P5Wrapper = dynamic(() => import('react-p5'), {\n    ssr: false,\n});\n\ninterface P5Props {\n    setup: (p: any, canvasParentRef: any) => void\n    draw: (p: any) => void;\n    windowResized: (p: any) => void;\n  }\n\n  const Sketch: React.FC<P5Props> = ({setup,draw, windowResized}) => {\n    const canvasRef = useRef<HTMLDivElement>(null)\n    return (<P5Wrapper setup={(p: any) => setup(p, canvasRef.current)} draw={draw} windowResized={windowResized} />);\n}\n\nconst SnakeGame: React.FC = () => {\n    const canvasRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        let sketch: any;\n        if (typeof window !== \"undefined\") {\n      let blocksX = 40, blocksY = 20;\n      let maxBlocks = 1000, blockSize: number, xOffset = 0, yOffset = 0, s: any, pause = false, speedMultiplier = 1, hc: any, outlineLength = 3, setup_i = 0;\n        \n        const setup = (p: any, canvasParentRef: any) => {\n            setup_i++;\n            let a = canvasParentRef;\n            if (!a) return; // Ensure canvasRef.current is defined\n            blockSize = Math.min(a.offsetWidth / blocksX, a.offsetHeight / blocksY);\n            p.createCanvas(a.offsetWidth - blockSize, a.offsetHeight - blockSize).parent(a);\n            p.pixelDensity(15);\n            setBlocks(p);\n            blockSize = Math.min(p.width / blocksX, p.height / blocksY);\n            outlineLength = blockSize / 15;\n            yOffset = xOffset = 0;\n            if (setup_i == 1) setup(p, canvasParentRef);\n            s = new Snake(p);\n            hc = new HamiltonianCycle(blocksX, blocksY, p);\n            s.resetOnHamiltonian(hc.cycle);\n            p.frameRate(30);\n          \n            let isSpeedUp = false;\n            const toggleSpeed = () => {\n                isSpeedUp = !isSpeedUp;\n                speedMultiplier = isSpeedUp ? 10 : 1;\n            }\n            \n            if (a) {\n              a.addEventListener('mouseover', toggleSpeed);\n              a.addEventListener('mouseout', toggleSpeed);\n              a.addEventListener('touchstart', toggleSpeed);\n            }\n            \n            window.addEventListener(\"resize\", resize(p));\n        };\n\n          const setBlocks = (p: any) => {\n              let a = 1;\n              for (; ;) {\n                  if (Math.floor(p.width / a) * Math.floor(p.height / a) < maxBlocks) {\n                      blockSize = a;\n                      blocksX = Math.floor(p.width / blockSize) - Math.floor(p.width / blockSize) % 2 - 2;\n                      blocksY = Math.floor(p.height / blockSize) - Math.floor(p.height / blockSize) % 2;\n                      break;\n                  } else a++;\n              }\n          };\n          const resize = (p:any) => () => {\n              blockSize = Math.min(p.width / blocksX, p.height / blocksY);\n              outlineLength = blockSize / 15;\n              xOffset = (p.width - blockSize * blocksX) / 2;\n              yOffset = (p.height - blockSize * blocksY) / 2;\n              setup(p, canvasRef.current);\n          }\n          let resizeDelay: any;\n          const windowResized = (p: any) => {\n              clearTimeout(resizeDelay);\n              resizeDelay = setTimeout(() => resize(p)(), 500)\n          }\n         const draw = (p: any) => {\n              if (!pause) {\n                p.background(\"#202222\");\n                p.stroke(\"#202222\");\n                p.strokeWeight(1);\n                p.fill(20);\n                p.rect(0, 0, p.width, yOffset);\n                p.rect(0, 0, xOffset, p.height);\n                p.rect(p.width, p.height, -p.width, -yOffset);\n                p.rect(p.width, p.height, -xOffset, -p.height);\n                p.push();\n                p.translate(xOffset, yOffset);\n                p.fill(0);\n                s.show();\n                for (let a = 0; a < speedMultiplier; a++) s.update();\n                p.pop();\n              }\n          };\n\n         class Snake {\n              x: number;\n              y: number;\n              tailBlocks: any[];\n              velX: number;\n              velY: number;\n              apple: any;\n              addCount: number;\n              survivalMode: boolean;\n              dead: boolean;\n              path: any;\n              weWin: boolean;\n              lateGame: boolean;\n              noMoreAStar: boolean;\n              searchForLongestPathModeActive: boolean;\n              controlledByPlayer: boolean;\n              cycle: any;\n              headCyclePosition: number;\n              tailCyclePosition: number;\n              appleCyclePosition: any;\n              constructor(p: any) {\n                this.x = Math.floor(blocksX / 2);\n                this.y = Math.floor(blocksY / 2);\n                this.tailBlocks = [];\n                this.tailBlocks.push(p.createVector(this.x - 3, this.y));\n                this.tailBlocks.push(p.createVector(this.x - 2, this.y));\n                this.tailBlocks.push(p.createVector(this.x - 1, this.y));\n                this.velX = 1;\n                this.velY = 0;\n                this.apple = new Apple(this,p);\n                this.addCount = 0;\n                this.survivalMode = this.dead = false;\n                this.path = null;\n                this.weWin = this.lateGame = this.noMoreAStar = this.searchForLongestPathModeActive = this.controlledByPlayer = false;\n                this.cycle = null;\n                this.headCyclePosition = 0;\n                this.tailCyclePosition = 0;\n              }\n              resetOnHamiltonian(a: any) {\n                this.cycle = a;\n                this.tailBlocks = [];\n                this.tailBlocks.push(p.createVector(a[0].x, a[0].y));\n                this.tailBlocks.push(p.createVector(a[1].x, a[1].y));\n                this.tailBlocks.push(p.createVector(a[2].x, a[2].y));\n                this.x = a[3].x;\n                this.y = a[3].y;\n                this.apple = new Apple(this,p);\n                this.headCyclePosition = 3;\n                this.tailCyclePosition = 0;\n              }\n                show() {\n                    p.noStroke();\n                    p.fill(\"#e8e8e6\");\n                    p.ellipse(this.x * blockSize + blockSize / 2, this.y * blockSize + blockSize / 2, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    p.rect((this.x + this.tailBlocks[this.tailBlocks.length - 1].x) * blockSize / 2 + outlineLength, (this.y + this.tailBlocks[this.tailBlocks.length - 1].y) * blockSize / 2 + outlineLength, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    for (var a = 0; a < this.tailBlocks.length; a++)\n                        p.ellipse(this.tailBlocks[a].x * blockSize + blockSize / 2, this.tailBlocks[a].y * blockSize + blockSize / 2, blockSize - outlineLength * 2, blockSize - outlineLength * 2),\n                            a < this.tailBlocks.length - 1 && p.rect((this.tailBlocks[a].x + this.tailBlocks[a + 1].x) / 2 * blockSize + outlineLength, (this.tailBlocks[a].y + this.tailBlocks[a + 1].y) / 2 * blockSize + outlineLength, blockSize - outlineLength * 2, blockSize - outlineLength * 2);\n                    this.weWin || this.apple.show();\n                }\n                move() {\n                    if (!this.weWin) {\n                        if (!this.controlledByPlayer)\n                            if ((!this.path || this.path.pathCounter >= this.path.pathLength) && this.calculatePath(p), this.path && this.path.pathLength !== 0) {\n                                var a = this.path.getNextMove();\n                                this.velX = a.x;\n                                this.velY = a.y;\n                            } else {\n                                var a = this.getNextPosition(p);\n                                this.velX = a.x - this.x;\n                                this.velY = a.y - this.y;\n                            }\n                        this.addCount <= 0 ? (this.tailBlocks.splice(0, 1), this.tailCyclePosition = (this.tailCyclePosition + 1) % this.cycle.length) : this.addCount--;\n                        this.tailBlocks.push(p.createVector(this.x, this.y));\n                        this.x += this.velX;\n                        this.y += this.velY;\n                    }\n                }\n                getNextPosition(p:any) {\n                    this.appleCyclePosition = hc.getNodeNo(this.apple.x, this.apple.y);\n                    let a = hc.getPossiblePositionsFrom(this.x, this.y),\n                        b = 100000,\n                        c = 0;\n                    for (let d = 0; d < a.length; d++) {\n                        let e = this.appleCyclePosition - a[d];\n                        for (; e < 0;) e += this.cycle.length;\n                        !this.overTakesTail(this.cycle[a[d]], undefined, undefined,p) && e < b && (b = e, c = d);\n                    }\n                    return b === 100000 ? this.cycle[(hc.getNodeNo(this.x, this.y) + 1) % this.cycle.length] : this.cycle[a[c]];\n                }\n              overTakesTail(a: any, b?: any, c?: any, p?:any) {\n                  b = b ? b.cycleNo : hc.getNodeNo(this.x, this.y);\n                  c = c ? hc.getNodeNo(c.x, c.y) : hc.getNodeNo(this.tailBlocks[0].x, this.tailBlocks[0].y);\n                  if (this.getDistanceBetweenPoints(b, c) <= 50 + this.addCount) return true;\n                  c = c - 50 - this.addCount;\n                  c < 0 && (c += this.cycle.length);\n                  return this.getDistanceBetweenPoints(b, a.cycleNo) >= this.getDistanceBetweenPoints(b, c) ? true : false;\n              }\n                getPathBasedOnAStar(p: any) {\n                  for (var a of this.cycle) a.resetForAStar();\n                    this.appleCyclePosition = hc.getNodeNo(this.apple.x, this.apple.y);\n                  var b = this.cycle[hc.getNodeNo(this.x, this.y)];\n                    a = [];\n                    let c: any;\n                    b = new HPath(b, this.cycle[this.appleCyclePosition],p);\n                    for (a.push(b);;) {\n                        if (a.length === 0) return c;\n                      b = a.shift();\n                        if (c && b.pathLength >= c.pathLength) continue;\n                        if (b.distanceToApple === 0) {\n                            if (c == null || b.pathLength < c.pathLength) c = b.clone();\n                            continue;\n                        }\n                        let e = b.getLastNode();\n                        if (!e.alreadyVisited || b.pathLength < e.shortestDistanceToThisPoint) {\n                            e.alreadyVisited = true;\n                            e.shortestDistanceToThisPoint = b.pathLength;\n                            for (var d of e.edges) {\n                              if (this.overTakesTail(d, e, b.getSnakeTailPositionAfterFollowingPath(this), p) && d.cycleNo !== e.cycleNo + 1) continue;\n                                let f = b.clone();\n                                f.addToTail(d);\n                                f.getLastNode().alreadyVisited && f.pathLength > f.getLastNode().shortestDistanceToThisPoint || a.push(f);\n                            }\n                        }\n                        a.sort((f: HPath, n: HPath) => f.distanceToApple + f.pathLength - (n.distanceToApple + n.pathLength));\n                    }\n                }\n                getDistanceBetweenPoints(a: any, b: any) {\n                  for (a = b - a; a < 0;) a += this.cycle.length;\n                  return a;\n              }\n              checkFuturePos(p: any) {\n                  this.x += this.velX;\n                  this.y += this.velY;\n                  for (var a = 0; a < this.tailBlocks.length; a++) this.tailBlocks[a].x === this.x && this.tailBlocks[a].y === this.y && (this.dead = true);\n                  if (this.x < 0 || this.x >= blocksX || this.y < 0 || this.y >= blocksY) this.dead = true;\n                  this.x -= this.velX;\n                  this.y -= this.velY;\n                  this.dead && (this.dead = false, pause = true);\n              }\n                update() {\n                    this.dead || (this.move(), this.checkCollisions(p));\n                }\n                checkCollisions(p: any) {\n                    if (blocksX * blocksY - (this.tailBlocks.length + 1) <= 0) this.weWin = true, setup(p, canvasRef.current);\n                    else {\n                        for (var a = 0; a < this.tailBlocks.length; a++) if (this.tailBlocks[a].x === this.x && this.tailBlocks[a].y === this.y) {\n                            this.dead = true;\n                            return;\n                        }\n                        this.x < 0 || this.x >= blocksX || this.y < 0 || this.y >= blocksY ? this.dead = true : this.x === this.apple.x && this.y === this.apple.y && this.ateApple(p);\n                    }\n                }\n                ateApple(p: any) {\n                    this.addCount += 4;\n                    this.apple = new Apple(this,p);\n                    this.calculatePath(p);\n                }\n                calculatePath(p: any) {\n                    this.path = this.getPathBasedOnAStar(p);\n                }\n                isAppleOnSnake(a: any) {\n                    return this.snakeAtPosition(a.x, a.y);\n                }\n                snakeAtPosition(a: any, b: any) {\n                    return this.snakeTailAtPosition(a, b) || this.x == a && this.y == b;\n                }\n                snakeTailAtPosition(a: any, b: any) {\n                  for (var c = 0; c < this.tailBlocks.length; c++) if (this.tailBlocks[c].x == a && this.tailBlocks[c].y == b) return true;\n                    return false;\n                }\n            }\n          class Apple {\n              x: number;\n              y: number;\n              constructor(a: Snake,p: any) {\n                  this.x = Math.floor(p.random(blocksX));\n                  for (this.y = Math.floor(p.random(blocksY)); a.isAppleOnSnake(this);) this.x = Math.floor(p.random(blocksX)), this.y = Math.floor(p.random(blocksY));\n                \n              }\n            show() {\n                p.noStroke();\n                p.fill(\"#21b8cd\");\n                p.push();\n                p.translate(this.x * blockSize + outlineLength, this.y * blockSize + outlineLength);\n                p.ellipse(blockSize / 2, blockSize / 2, blockSize - 2 * outlineLength, blockSize - 2 * outlineLength);\n                p.pop();\n            }\n                isAtPosition(a: any, b: any) {\n                  return this.x === a && this.y === b;\n              }\n          }\n\n          class HamiltonianCycle {\n              w: number;\n              h: number;\n              cycle: any[];\n              spanningTreeNodes: HNode[];\n              constructor(a: number, b: number,p: any) {\n                  this.w = a;\n                  this.h = b;\n                this.cycle = [];\n                  this.spanningTreeNodes = [];\n                this.createCycle(p);\n              }\n              createCycle(p: any) {\n                this.createSpanningTree(p);\n                  var a:any[] = [];\n                  let b:HNode[] = [];\n                  for (let i = 0; i < this.w; i++)\n                      for (var c = 0; c < this.h; c++) b.push(new HNode(i, c));\n                  for (var d of b) d.setEdges(b);\n                  for (let i = 0; i < this.spanningTreeNodes.length; i++) {\n                      let d = this.spanningTreeNodes[i];\n                      for (let e of d.spanningTreeAdjacentNodes) {\n                          let c = (p: any, t: any, q: any, u: any) => {\n                              t + this.h * p >= b.length || u + this.h * q >= b.length || (p = b[t + this.h * p], q = b[u + this.h * q], p.spanningTreeAdjacentNodes.push(q), q.spanningTreeAdjacentNodes.push(p))\n                          };\n                          let k = d.getDirectionTo(e),\n                              l = d.x * 2,\n                              m = d.y * 2;\n                          k.x === 1 ? (c(l + 1, m, l + 2, m), c(l + 1, m + 1, l + 2, m + 1)) :\n                              k.y === 1 && (c(l, m + 1, l, m + 2), c(l + 1, m + 1, l + 1, m + 2));\n                      }\n                  }\n                  a = b.filter(k => k.spanningTreeAdjacentNodes.length === 1);\n                    let e: HEdge[] = [];\n                    for (let f of a) {\n                        let dir = f.spanningTreeAdjacentNodes[0].getDirectionTo(f);\n                        dir.x += f.x;\n                        dir.y += f.y;\n                        let edge = new HEdge(b[dir.y + this.h * dir.x], f);\n                        let d = true;\n                        for (let n of e) if (n.isEqualTo(edge)) {\n                            d = false;\n                            break;\n                        }\n                        d && e.push(edge);\n                    }\n                  for (let k of e) k.connectNodes();\n                  a = b.filter(k => k.spanningTreeAdjacentNodes.length === 1);\n                    e = [];\n                    for (let g of a)\n                        for (let h of a)\n                            if (p.dist(g.x, g.y, h.x, h.y) === 1 && Math.floor(g.x / 2) === Math.floor(h.x / 2) && Math.floor(g.y / 2) === Math.floor(h.y / 2)) {\n                                let f = new HEdge(h, g);\n                                let n = true;\n                                for (let r of e) if (r.isEqualTo(f)) {\n                                    n = false;\n                                    break;\n                                }\n                                n && e.push(f);\n                                break;\n                            }\n                  for (let k of e) k.connectNodes();\n                let randomElement = b[Math.floor(p.random(b.length))];\n                a = [randomElement];\n                  let g = a[0];\n                  for (let h = a[0].spanningTreeAdjacentNodes[0]; h !== a[0];) {\n                      let r = h.spanningTreeAdjacentNodes[0];\n                      r === g && (r = h.spanningTreeAdjacentNodes[1]);\n                      a.push(h);\n                      g = h;\n                      h = r;\n                  }\n                  this.cycle = a;\n                for (g = 0; g < this.cycle.length; g++) this.cycle[g].cycleNo = g;\n              }\n              show(p: any) {\n                  for (let a = 0; a < this.cycle.length; a++)\n                      p.push(),\n                          p.translate(blockSize / 2, blockSize / 2),\n                          p.scale(blockSize),\n                          p.fill(255),\n                          p.textAlign(p.CENTER, p.CENTER),\n                          p.textSize(.3),\n                          p.text(a, this.cycle[a].x, this.cycle[a].y),\n                          p.stroke(255, 100),\n                          p.strokeWeight(.1),\n                          a !== this.cycle.length - 1 ? p.line(this.cycle[a].x, this.cycle[a].y, this.cycle[a + 1].x, this.cycle[a + 1].y) :\n                              p.line(this.cycle[a].x, this.cycle[a].y, this.cycle[0].x, this.cycle[0].y),\n                          p.pop();\n              }\n              createSpanningTree(p: any) {\n                  let a: HNode[] = [];\n                  for (var b = 0; b < this.w / 2; b++) for (let i = 0; i < this.h / 2; i++) a.push(new HNode(b, i));\n                  for (var d of a) d.setEdges(a);\n                  let edges: HEdge[] = [];\n                  let c = a[Math.floor(p.random(a.length))];\n                  edges.push(new HEdge(c, c.edges[0]));\n                  let e = [c, c.edges[0]];\n                  for (; e.length < a.length;) {\n                      c = (e as any).getRandomElement(p);\n                      const filteredEdges = c.edges.filter((f: HNode) => !e.includes(f));\n                      if (filteredEdges.length !== 0) {\n                          d = (filteredEdges as any).getRandomElement(p);\n                          e.push(d);\n                          edges.push(new HEdge(c, d));\n                      }\n                  }\n                  for (let f of a) f.setSpanningTreeEdges(edges);\n                  this.spanningTreeNodes = a;\n              }\n              getNextPosition(a: any, b: any) {\n                  for (let c = 0; c < this.cycle.length; c++) if (this.cycle[c].x === a && this.cycle[c].y === b) return this.cycle[(c + 1) % this.cycle.length];\n                  return null;\n              }\n              getNodeNo(a: any, b: any) {\n                  for (let c = 0; c < this.cycle.length; c++) if (this.cycle[c].x === a && this.cycle[c].y === b) return c;\n                  return -1;\n              }\n              getPossiblePositionsFrom(a: any, b: any) {\n                  a = this.cycle[this.getNodeNo(a, b)];\n                  let positions: number[] = [];\n                  for (let c of a.edges) positions.push(this.getNodeNo(c.x, c.y));\n                  return positions;\n              }\n          }\n           \n          (Array.prototype as any).getRandomElement = function (p: any): any {\n            return this[Math.floor(p.random(this.length))];\n          };\n\n          class HNode {\n              x: number;\n              y: number;\n              spanningTreeAdjacentNodes: HNode[];\n              cycleNo: number;\n              alreadyVisited: boolean;\n              shortestDistanceToThisPoint: number;\n              edges: HNode[];\n            constructor(a: number, b: number) {\n                  this.x = a;\n                  this.y = b;\n                  this.spanningTreeAdjacentNodes = [];\n                  this.cycleNo = -1;\n                  this.alreadyVisited = false;\n                  this.shortestDistanceToThisPoint = 0;\n                this.edges = [];\n              }\n              setEdges(a: HNode[]) {\n                this.edges = a.filter(b => p.dist(b.x, b.y, this.x, this.y) === 1)\n              }\n              setSpanningTreeEdges(a: HEdge[]) {\n                  for (let b of a) b.contains(this) && this.spanningTreeAdjacentNodes.push(b.getOtherNode(this));\n              }\n              getNextNodeMovingLeft(a: HNode): HNode {\n                let b = a.getDirectionTo(this);\n                let directions: { x: number; y: number; }[] = [];\n                for (var c of this.spanningTreeAdjacentNodes) directions.push(this.getDirectionTo(c));\n                for (let c = getLeftOf(b); !directions.some(dir => dir.x === c.x && dir.y === c.y);) c = getRightOf(c);\n                return this.spanningTreeAdjacentNodes[directions.findIndex(dir => dir.x === c.x && dir.y === c.y)];\n              }\n              getDirectionTo(a: HNode): { x: number; y: number; } {\n                return { x: a.x - this.x, y: a.y - this.y };\n              }\n              resetForAStar() {\n                  this.alreadyVisited = false;\n                  this.shortestDistanceToThisPoint = 0;\n              }\n          }\n           function getLeftOf(a: { x: number; y: number; }): { x: number; y: number; } {\n              return a.x === 0 && a.y === 1 ? { x: 1, y: 0 } :\n                  a.x === 0 && a.y === -1 ? { x: -1, y: 0 } :\n                      a.x === 1 ? { x: 0, y: -1 } : { x: 0, y: 1 }\n          }\n          function getRightOf(a: { x: number; y: number; }): { x: number; y: number; } {\n              return a.x === 0 && a.y === 1 ? { x: -1, y: 0 } :\n                  a.x === 0 && a.y === -1 ? { x: 1, y: 0 } :\n                      a.x === 1 ? { x: 0, y: 1 } : { x: 0, y: -1 }\n          }\n          class HEdge {\n              node1: HNode;\n              node2: HNode;\n              constructor(a: HNode, b: HNode) {\n                  this.node1 = a;\n                  this.node2 = b;\n              }\n              isEqualTo(a: HEdge): boolean {\n                  return this.node1 === a.node1 && this.node2 === a.node2 || this.node1 === a.node2 && this.node2 === a.node1;\n              }\n              contains(a: HNode): boolean {\n                  return a === this.node1 || a === this.node2;\n              }\n              getOtherNode(a: HNode): HNode {\n                  return a === this.node1 ? this.node2 : this.node1;\n              }\n              connectNodes() {\n                  this.node1.spanningTreeAdjacentNodes.push(this.node2);\n                  this.node2.spanningTreeAdjacentNodes.push(this.node1);\n              }\n          }\n          class HPath {\n              pathLength: number;\n              nodesInPath: HNode[];\n              finishNode: HNode;\n              distanceToApple: number;\n              pathCounter: number;\n              constructor(a: HNode, b: HNode, p: any) {\n                  this.pathLength = 0;\n                  this.nodesInPath = [a];\n                  this.finishNode = b;\n                  this.distanceToApple = 0;\n                  this.setDistanceToApple(p);\n                  this.pathCounter = 0;\n                \n              }\n              setDistanceToApple(p: any) {\n                  this.distanceToApple = p.dist(this.finishNode.x, this.finishNode.y, this.getLastNode().x, this.getLastNode().y);\n              }\n              addToTail(a: HNode) {\n                  this.nodesInPath.push(a);\n                  this.pathLength += 1;\n                  this.setDistanceToApple(p);\n              }\n              getLastNode(): HNode {\n                  return this.nodesInPath[this.nodesInPath.length - 1];\n              }\n              getSnakeTailPositionAfterFollowingPath(a: Snake): HNode {\n                  const tailBlocksAsHNodes = a.tailBlocks.map(block => new HNode(block.x, block.y));\n                  return this.pathLength - a.addCount < tailBlocksAsHNodes.length ?\n                      tailBlocksAsHNodes[Math.max(0, this.pathLength - a.addCount)]\n                      :\n                      this.nodesInPath[this.pathLength - a.addCount - tailBlocksAsHNodes.length];\n              }\n              getNextMove(): { x: number; y: number; } {\n                  let a = this.nodesInPath[this.pathCounter + 1].x - this.nodesInPath[this.pathCounter].x,\n                      b = this.nodesInPath[this.pathCounter + 1].y - this.nodesInPath[this.pathCounter].y;\n                  this.pathCounter++;\n                  return { x: a, y: b };\n              }\n              clone(): HPath {\n                  let a = new HPath(this.nodesInPath[0], this.finishNode,p);\n                  a.nodesInPath = [...this.nodesInPath];\n                  a.pathLength = this.pathLength;\n                  a.distanceToApple = this.distanceToApple;\n                  return a;\n              }\n          }\n          sketch = {setup, draw, windowResized};\n        }\n    }, []);\n    \n    return (\n        <div className=\"w-full aspect-[2.35/1] bg-[#202222] rounded-md border-[2px] border-[#3d3f40]\" id=\"snake-game-container\">\n            <div className=\"flex justify-center items-center h-full\" id=\"snake-game\" ref={canvasRef} style={{ width: '100%', height: '100%' }}>\n                {typeof window !== 'undefined' && <Sketch setup={sketch?.setup} draw={sketch?.draw} windowResized={sketch?.windowResized} />}\n            </div>\n        </div>\n    );\n};\n\nexport default SnakeGame;"],"names":[],"mappings":";;;;AACA;AACA;AAFA;;;;AAIA,MAAM,YAAY,CAAA,GAAA,+JAAA,CAAA,UAAO,AAAD;;;;;;;;IACpB,KAAK;;AASP,MAAM,SAA4B,CAAC,EAAC,KAAK,EAAC,IAAI,EAAE,aAAa,EAAC;IAC5D,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAkB;IACzC,qBAAQ,8OAAC;QAAU,OAAO,CAAC,IAAW,MAAM,GAAG,UAAU,OAAO;QAAG,MAAM;QAAM,eAAe;;;;;;AAClG;AAEA,MAAM,YAAsB;IACxB,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAkB;IAEzC,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACN,IAAI;QACJ,uCAAmC;;YA8E5B,IAAA;YA4KC,IAAA;YAqBA,IAAA;YAkIA,IAAA;YAsCL,SAAS,UAAU,CAA4B;gBAC5C;YAGJ;YACA,SAAS,WAAW,CAA4B;gBAC5C;YAGJ;YACM,IAAA;YAqBA,IAAA;QAgDR;IACJ,GAAG,EAAE;IAEL,qBACI,8OAAC;QAAI,WAAU;QAA+E,IAAG;kBAC7F,cAAA,8OAAC;YAAI,WAAU;YAA0C,IAAG;YAAa,KAAK;YAAW,OAAO;gBAAE,OAAO;gBAAQ,QAAQ;YAAO;sBAC3H,gBAAkB,6BAAe,8OAAC;gBAAO,OAAO,QAAQ;gBAAO,MAAM,QAAQ;gBAAM,eAAe,QAAQ;;;;;;;;;;;;;;;;AAI3H;uCAEe"}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/app/page.tsx"],"sourcesContent":["\"use client\"\nimport type { NextPage } from 'next';\nimport SnakeGame from './snake';\nimport { useEffect } from 'react';\n\n\nconst Home: NextPage = () => {\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n        try {\n            // Any initialization code can go here\n            console.log(\"Home component mounted\");\n        } catch (error) {\n            console.error(\"Error during Home component initialization:\", error);\n        }\n    }\n}, []);\n    return (\n      <main>\n        <div className=\"flex flex-col items-center justify-center h-screen mx-auto max-w-xl px-6\">  \n          <h1 className=\"text-4xl font-bold mb-8 xanh-mono-font\">A Perfect Snake AI</h1>\n          <SnakeGame /> \n        </div> \n      </main>\n    );\n};\n\nexport default Home;"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;;AAMA,MAAM,OAAiB;IACrB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,uCAAmC;;QAOnC;IACJ,GAAG,EAAE;IACD,qBACE,8OAAC;kBACC,cAAA,8OAAC;YAAI,WAAU;;8BACb,8OAAC;oBAAG,WAAU;8BAAyC;;;;;;8BACvD,8OAAC,6GAAA,CAAA,UAAS;;;;;;;;;;;;;;;;AAIpB;uCAEe"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":";AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;AAEzC,OAAO;IACL,IAAIF,QAAQC,GAAG,CAACK,uBAA2B,EAAF;;IAQzC,OAAO;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1CJ,OAAOC,OAAO,GAAGC,QAAQ;QAC3B,OAAO,IAAIL,QAAQC,GAAG,CAACO,SAAS,EAAE;;QAIlC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-ssr'\n].ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,0HAAyBC,QAAQ,CACxD,YACD,CAACC,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored['react-ssr'].React\n"],"names":["module","exports","require","vendored","React"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,0HAAyBC,QAAQ,CAAC,YAAY,CAACC,KAAK","ignoreList":[0]}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/%40swc/helpers/cjs/_interop_require_default.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n"],"names":[],"mappings":"AAAA;AAEA,SAAS,yBAAyB,GAAG;IACjC,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AACxD;AACA,QAAQ,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-ssr'\n].ReactJsxRuntime\n"],"names":["module","exports","require","vendored","ReactJsxRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,0HAAyBC,QAAQ,CACxD,YACD,CAACC,eAAe","ignoreList":[0]}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n"],"names":["BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","Error","constructor","reason","digest","err"],"mappings":"AAAA,+GAA+G;;;;;;;;;;;;;;;;IAIlGA,iBAAiB,EAAA;eAAjBA;;IASGC,mBAAmB,EAAA;eAAnBA;;;AAZhB,MAAMC,iBAAiB;AAGhB,MAAMF,0BAA0BG;IAGrCC,YAA4BC,MAAc,CAAE;QAC1C,KAAK,CAAE,wCAAqCA,SAAAA,IAAAA,CADlBA,MAAAA,GAAAA,QAAAA,IAAAA,CAFZC,MAAAA,GAASJ;IAIzB;AACF;AAGO,SAASD,oBAAoBM,GAAY;IAC9C,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.tsx"],"sourcesContent":["'use client'\n\nimport type { ReactElement } from 'react'\nimport { BailoutToCSRError } from './bailout-to-csr'\n\ninterface BailoutToCSRProps {\n  reason: string\n  children: ReactElement\n}\n\n/**\n * If rendered on the server, this component throws an error\n * to signal Next.js that it should bail out to client-side rendering instead.\n */\nexport function BailoutToCSR({ reason, children }: BailoutToCSRProps) {\n  if (typeof window === 'undefined') {\n    throw new BailoutToCSRError(reason)\n  }\n\n  return children\n}\n"],"names":["BailoutToCSR","reason","children","window","BailoutToCSRError"],"mappings":"AAAA;;;;;+BAcgBA,gBAAAA;;;eAAAA;;;8BAXkB;AAW3B,SAASA,aAAa,KAAuC;IAAvC,IAAA,EAAEC,MAAM,EAAEC,QAAQ,EAAqB,GAAvC;IAC3B,IAAI,OAAOC,WAAW,aAAa;QACjC,MAAM,IAAIC,cAAAA,iBAAiB,CAACH;IAC9B;IAEA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-dom.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored['react-ssr'].ReactDOM\n"],"names":["module","exports","require","vendored","ReactDOM"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,0HAAyBC,QAAQ,CAAC,YAAY,CAACC,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/encode-uri-path.ts"],"sourcesContent":["export function encodeURIPath(file: string) {\n  return file\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')\n}\n"],"names":["encodeURIPath","file","split","map","p","encodeURIComponent","join"],"mappings":";;;;+BAAgBA,iBAAAA;;;eAAAA;;;AAAT,SAASA,cAAcC,IAAY;IACxC,OAAOA,KACJC,KAAK,CAAC,KACNC,GAAG,CAAC,CAACC,IAAMC,mBAAmBD,IAC9BE,IAAI,CAAC;AACV","ignoreList":[0]}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/lazy-dynamic/preload-chunks.tsx"],"sourcesContent":["'use client'\n\nimport { preload } from 'react-dom'\n\nimport { workAsyncStorage } from '../../../server/app-render/work-async-storage.external'\nimport { encodeURIPath } from '../encode-uri-path'\n\nexport function PreloadChunks({\n  moduleIds,\n}: {\n  moduleIds: string[] | undefined\n}) {\n  // Early return in client compilation and only load requestStore on server side\n  if (typeof window !== 'undefined') {\n    return null\n  }\n\n  const workStore = workAsyncStorage.getStore()\n  if (workStore === undefined) {\n    return null\n  }\n\n  const allFiles = []\n\n  // Search the current dynamic call unique key id in react loadable manifest,\n  // and find the corresponding CSS files to preload\n  if (workStore.reactLoadableManifest && moduleIds) {\n    const manifest = workStore.reactLoadableManifest\n    for (const key of moduleIds) {\n      if (!manifest[key]) continue\n      const chunks = manifest[key].files\n      allFiles.push(...chunks)\n    }\n  }\n\n  if (allFiles.length === 0) {\n    return null\n  }\n\n  return (\n    <>\n      {allFiles.map((chunk) => {\n        const href = `${workStore.assetPrefix}/_next/${encodeURIPath(chunk)}`\n        const isCss = chunk.endsWith('.css')\n        // If it's stylesheet we use `precedence` o help hoist with React Float.\n        // For stylesheets we actually need to render the CSS because nothing else is going to do it so it needs to be part of the component tree.\n        // The `preload` for stylesheet is not optional.\n        if (isCss) {\n          return (\n            <link\n              key={chunk}\n              // @ts-ignore\n              precedence=\"dynamic\"\n              href={href}\n              rel=\"stylesheet\"\n              as=\"style\"\n            />\n          )\n        } else {\n          // If it's script we use ReactDOM.preload to preload the resources\n          preload(href, {\n            as: 'script',\n            fetchPriority: 'low',\n          })\n          return null\n        }\n      })}\n    </>\n  )\n}\n"],"names":["PreloadChunks","moduleIds","window","workStore","workAsyncStorage","getStore","undefined","allFiles","reactLoadableManifest","manifest","key","chunks","files","push","length","map","chunk","href","assetPrefix","encodeURIPath","isCss","endsWith","link","precedence","rel","as","preload","fetchPriority"],"mappings":"AAAA;;;;;+BAOgBA,iBAAAA;;;eAAAA;;;;0BALQ;0CAES;+BACH;AAEvB,SAASA,cAAc,KAI7B;IAJ6B,IAAA,EAC5BC,SAAS,EAGV,GAJ6B;IAK5B,+EAA+E;IAC/E,IAAI,OAAOC,WAAW,aAAa;QACjC,OAAO;IACT;IAEA,MAAMC,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;IAC3C,IAAIF,cAAcG,WAAW;QAC3B,OAAO;IACT;IAEA,MAAMC,WAAW,EAAE;IAEnB,4EAA4E;IAC5E,kDAAkD;IAClD,IAAIJ,UAAUK,qBAAqB,IAAIP,WAAW;QAChD,MAAMQ,WAAWN,UAAUK,qBAAqB;QAChD,KAAK,MAAME,OAAOT,UAAW;YAC3B,IAAI,CAACQ,QAAQ,CAACC,IAAI,EAAE;YACpB,MAAMC,SAASF,QAAQ,CAACC,IAAI,CAACE,KAAK;YAClCL,SAASM,IAAI,IAAIF;QACnB;IACF;IAEA,IAAIJ,SAASO,MAAM,KAAK,GAAG;QACzB,OAAO;IACT;IAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBACGP,SAASQ,GAAG,CAAC,CAACC;YACb,MAAMC,OAAUd,UAAUe,WAAW,GAAC,YAASC,CAAAA,GAAAA,eAAAA,aAAa,EAACH;YAC7D,MAAMI,QAAQJ,MAAMK,QAAQ,CAAC;YAC7B,wEAAwE;YACxE,0IAA0I;YAC1I,gDAAgD;YAChD,IAAID,OAAO;gBACT,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACE,QAAAA;oBAEC,aAAa;oBACbC,YAAW;oBACXN,MAAMA;oBACNO,KAAI;oBACJC,IAAG;mBALET;YAQX,OAAO;gBACL,kEAAkE;gBAClEU,CAAAA,GAAAA,UAAAA,OAAO,EAACT,MAAM;oBACZQ,IAAI;oBACJE,eAAe;gBACjB;gBACA,OAAO;YACT;QACF;;AAGN","ignoreList":[0]}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/lazy-dynamic/loadable.tsx"],"sourcesContent":["import { Suspense, Fragment, lazy } from 'react'\nimport { BailoutToCSR } from './dynamic-bailout-to-csr'\nimport type { ComponentModule } from './types'\nimport { PreloadChunks } from './preload-chunks'\n\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule<P>(\n  mod: React.ComponentType<P> | ComponentModule<P> | undefined\n): {\n  default: React.ComponentType<P>\n} {\n  // Check \"default\" prop before accessing it, as it could be client reference proxy that could break it reference.\n  // Cases:\n  // mod: { default: Component }\n  // mod: Component\n  // mod: { default: proxy(Component) }\n  // mod: proxy(Component)\n  const hasDefault = mod && 'default' in mod\n  return {\n    default: hasDefault\n      ? (mod as ComponentModule<P>).default\n      : (mod as React.ComponentType<P>),\n  }\n}\n\nconst defaultOptions = {\n  loader: () => Promise.resolve(convertModule(() => null)),\n  loading: null,\n  ssr: true,\n}\n\ninterface LoadableOptions {\n  loader?: () => Promise<React.ComponentType<any> | ComponentModule<any>>\n  loading?: React.ComponentType<any> | null\n  ssr?: boolean\n  modules?: string[]\n}\n\nfunction Loadable(options: LoadableOptions) {\n  const opts = { ...defaultOptions, ...options }\n  const Lazy = lazy(() => opts.loader().then(convertModule))\n  const Loading = opts.loading\n\n  function LoadableComponent(props: any) {\n    const fallbackElement = Loading ? (\n      <Loading isLoading={true} pastDelay={true} error={null} />\n    ) : null\n\n    // If it's non-SSR or provided a loading component, wrap it in a suspense boundary\n    const hasSuspenseBoundary = !opts.ssr || !!opts.loading\n    const Wrap = hasSuspenseBoundary ? Suspense : Fragment\n    const wrapProps = hasSuspenseBoundary ? { fallback: fallbackElement } : {}\n    const children = opts.ssr ? (\n      <>\n        {/* During SSR, we need to preload the CSS from the dynamic component to avoid flash of unstyled content */}\n        {typeof window === 'undefined' ? (\n          <PreloadChunks moduleIds={opts.modules} />\n        ) : null}\n        <Lazy {...props} />\n      </>\n    ) : (\n      <BailoutToCSR reason=\"next/dynamic\">\n        <Lazy {...props} />\n      </BailoutToCSR>\n    )\n\n    return <Wrap {...wrapProps}>{children}</Wrap>\n  }\n\n  LoadableComponent.displayName = 'LoadableComponent'\n\n  return LoadableComponent\n}\n\nexport default Loadable\n"],"names":["convertModule","mod","hasDefault","default","defaultOptions","loader","Promise","resolve","loading","ssr","Loadable","options","opts","Lazy","lazy","then","Loading","LoadableComponent","props","fallbackElement","isLoading","pastDelay","error","hasSuspenseBoundary","Wrap","Suspense","Fragment","wrapProps","fallback","children","window","PreloadChunks","moduleIds","modules","BailoutToCSR","reason","displayName"],"mappings":";;;;+BA4EA,WAAA;;;eAAA;;;;uBA5EyC;qCACZ;+BAEC;AAE9B,yFAAyF;AACzF,qGAAqG;AACrG,qEAAqE;AACrE,SAASA,cACPC,GAA4D;IAI5D,iHAAiH;IACjH,SAAS;IACT,8BAA8B;IAC9B,iBAAiB;IACjB,qCAAqC;IACrC,wBAAwB;IACxB,MAAMC,aAAaD,OAAO,aAAaA;IACvC,OAAO;QACLE,SAASD,aACJD,IAA2BE,OAAO,GAClCF;IACP;AACF;AAEA,MAAMG,iBAAiB;IACrBC,QAAQ,IAAMC,QAAQC,OAAO,CAACP,cAAc,IAAM;IAClDQ,SAAS;IACTC,KAAK;AACP;AASA,SAASC,SAASC,OAAwB;IACxC,MAAMC,OAAO;QAAE,GAAGR,cAAc;QAAE,GAAGO,OAAO;IAAC;IAC7C,MAAME,OAAAA,WAAAA,GAAOC,CAAAA,GAAAA,OAAAA,IAAI,EAAC,IAAMF,KAAKP,MAAM,GAAGU,IAAI,CAACf;IAC3C,MAAMgB,UAAUJ,KAAKJ,OAAO;IAE5B,SAASS,kBAAkBC,KAAU;QACnC,MAAMC,kBAAkBH,UAAAA,WAAAA,GACtB,CAAA,GAAA,YAAA,GAAA,EAACA,SAAAA;YAAQI,WAAW;YAAMC,WAAW;YAAMC,OAAO;aAChD;QAEJ,kFAAkF;QAClF,MAAMC,sBAAsB,CAACX,KAAKH,GAAG,IAAI,CAAC,CAACG,KAAKJ,OAAO;QACvD,MAAMgB,OAAOD,sBAAsBE,OAAAA,QAAQ,GAAGC,OAAAA,QAAQ;QACtD,MAAMC,YAAYJ,sBAAsB;YAAEK,UAAUT;QAAgB,IAAI,CAAC;QACzE,MAAMU,WAAWjB,KAAKH,GAAG,GAAA,WAAA,GACvB,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;gBAEG,OAAOqB,WAAW,cAAA,WAAA,GACjB,CAAA,GAAA,YAAA,GAAA,EAACC,eAAAA,aAAa,EAAA;oBAACC,WAAWpB,KAAKqB,OAAO;qBACpC;8BACJ,CAAA,GAAA,YAAA,GAAA,EAACpB,MAAAA;oBAAM,GAAGK,KAAK;;;2BAGjB,CAAA,GAAA,YAAA,GAAA,EAACgB,qBAAAA,YAAY,EAAA;YAACC,QAAO;sBACnB,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACtB,MAAAA;gBAAM,GAAGK,KAAK;;;QAInB,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACM,MAAAA;YAAM,GAAGG,SAAS;sBAAGE;;IAC/B;IAEAZ,kBAAkBmB,WAAW,GAAG;IAEhC,OAAOnB;AACT;MAEA,WAAeP","ignoreList":[0]}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/kongphopmengkuang/snakejs/node_modules/next/src/shared/lib/app-dynamic.tsx"],"sourcesContent":["import type React from 'react'\nimport type { JSX } from 'react'\nimport Loadable from './lazy-dynamic/loadable'\n\nimport type {\n  LoadableGeneratedOptions,\n  DynamicOptionsLoadingProps,\n  Loader,\n  LoaderComponent,\n} from './lazy-dynamic/types'\n\nexport {\n  type LoadableGeneratedOptions,\n  type DynamicOptionsLoadingProps,\n  type Loader,\n  type LoaderComponent,\n}\n\nexport type DynamicOptions<P = {}> = LoadableGeneratedOptions & {\n  loading?: () => JSX.Element | null\n  loader?: Loader<P>\n  loadableGenerated?: LoadableGeneratedOptions\n  modules?: string[]\n  ssr?: boolean\n}\n\nexport type LoadableOptions<P = {}> = DynamicOptions<P>\n\nexport type LoadableFn<P = {}> = (\n  opts: LoadableOptions<P>\n) => React.ComponentType<P>\n\nexport type LoadableComponent<P = {}> = React.ComponentType<P>\n\nexport default function dynamic<P = {}>(\n  dynamicOptions: DynamicOptions<P> | Loader<P>,\n  options?: DynamicOptions<P>\n): React.ComponentType<P> {\n  const loadableOptions: LoadableOptions<P> = {}\n\n  if (typeof dynamicOptions === 'function') {\n    loadableOptions.loader = dynamicOptions\n  }\n\n  const mergedOptions = {\n    ...loadableOptions,\n    ...options,\n  }\n\n  return Loadable({\n    ...mergedOptions,\n    modules: mergedOptions.loadableGenerated?.modules,\n  })\n}\n"],"names":["dynamic","dynamicOptions","options","mergedOptions","loadableOptions","loader","Loadable","modules","loadableGenerated"],"mappings":";;;;+BAkCA,WAAA;;;eAAwBA;;;;mEAhCH;AAgCN,SAASA,QACtBC,cAA6C,EAC7CC,OAA2B;QAehBC;IAbX,MAAMC,kBAAsC,CAAC;IAE7C,IAAI,OAAOH,mBAAmB,YAAY;QACxCG,gBAAgBC,MAAM,GAAGJ;IAC3B;IAEA,MAAME,gBAAgB;QACpB,GAAGC,eAAe;QAClB,GAAGF,OAAO;IACZ;IAEA,OAAOI,CAAAA,GAAAA,UAAAA,OAAQ,EAAC;QACd,GAAGH,aAAa;QAChBI,OAAO,EAAA,CAAEJ,mCAAAA,cAAcK,iBAAiB,KAAA,OAAA,KAAA,IAA/BL,iCAAiCI,OAAO;IACnD;AACF","ignoreList":[0]}},
    {"offset": {"line": 496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}